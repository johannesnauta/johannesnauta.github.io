<!doctype html><html lang=en-us><head><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/images/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/images/favicon-16x16.png><link rel=manifest href=/images/site.webmanifest><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="A simple, minimal blog for those who love text."><title>Stable communities | Home</title><link rel=stylesheet href=/css/style.css><link rel=stylesheet href=/css/fonts.css><link rel=stylesheet href=https://johannesnauta.github.io/css/theme-override.css><header><nav><ul><li class=pull-left><a href=https://johannesnauta.github.io>~/home</a></li><li class=pull-left><a href=/pages/research/>~/research</a></li><li class=pull-left><a href=/pages/publications/>~/publications</a></li><li class=pull-left><a href=/post/>~/posts</a></li><li class=pull-left><a href=/pages/cv/>~/curriculum-vitae</a></li><li class=pull-left><a href=/pages/contact/>~/contact</a></li></ul></nav></header></head><body><br><div class=article-meta><h1><span class=title>Stable communities</span></h1><h2 class=author>Johannes Nauta</h2><h2 class=date>2023/01/29</h2><p class=terms>Categories: <a href=/categories/mathematics-code-generalized-lotka-volterra-random-matrices>mathematics, code, generalized lotka-volterra, random matrices</a>
Tags: <a href=/tags/research-study>research, study</a></p></div><nav id=TableOfContents><ul><li><a href=#random-matrix-theory-the-distribution-of-eigenvalues-and-community-stability>Random matrix theory: the distribution of eigenvalues and community stability</a><ul><li><a href=#circular-law>Circular law</a></li><li><a href=#on-the-stability-of-random-communities>On the stability of random communities</a></li><li><a href=#random-communities-are-not-just-random>Random communities are not &lsquo;just&rsquo; random</a></li></ul></li><li><a href=#some-code-examples>Some code examples</a><ul><li><a href=#mays-matrix>May&rsquo;s matrix</a></li><li><a href=#allesina-and-tang-matrices>Allesina and Tang matrices</a></li></ul></li><li><a href=#plots>Plots</a></li><li><a href=#closing-thoughts>Closing thoughts</a></li></ul></nav><div class=content-wrapper><main><h1 id=stability-of-large-random-communities>Stability of large random communities</h1><p><b>Note</b>: | Most of the theory here is copied and/or derived from <a href=https://stefanoallesina.github.io/Sao_Paulo_School/intro.html#stability-of-large-random-communities>this excellent blog post</a> by <a href="https://scholar.google.com/citations?user=14DTOacAAAAJ&amp;hl=en&amp;oi=ao">Stefano Allesina</a>, an amazing ecologist that makes tremendous effort to understand the stability of complex ecosystems.
I basically just ported his <code>R</code>-code to <code>Julia</code>.</p><hr><p>Large ecological communities can often be captured in a matrix form.
This means that the generalized Lotka-Volterra model for $n$ species can be written in a compact form:
$$
\frac{dx(t)}{dt} = \boldsymbol{D}(x)
\big(r + \boldsymbol{A}x(t) \big),
$$
where $x(t)$ the state vector
&ndash; i.e. the population densities for the $n$ species &ndash;,
$\boldsymbol{D}$ a diagonal matrix with elements $x_i$ on the diagonal,
$r$ a vector of intrinsic growth/decay rates
(e.g. reproduction and/or mortality rate, depending on the sign),
and $\boldsymbol{A}$ an $n\times n$ matrix of interaction coefficients.</p><p>In the interest of the stability of ecological communities we look for solutions where
$r + \boldsymbol{A}x(t)$ has positive components.
Or, for some $i$, $x_i>0$ when $dx_i=0$.
We call this state $x^\dagger$ the feasible equilibrium.
Note that if $x^\dagger$ exists that is is <strong>unique</strong> and the solution of $x^\dagger = -\boldsymbol{A}^{-1}r$.
This means that $\boldsymbol{A}$ should have an inverse.</p><p>It is often interesting to check whether $x^\dagger$ is an attractor.
This problem is in general difficult to solve, so one often tests for local asymptotic stability instead.
To do this, describe the evolution of the ecological community as a system of nonlinear ODEs:
$$
\frac{dx_i}{dt} = f_i(x)
$$
and define the equilibrium as a vector of densities for which the derivative is $0$, i.e.
$$
\frac{dx_i^\dagger}{dt} = f_i(x^\dagger) = 0 \quad \forall i.
$$
Then, suppose a system is in a feasible equilibrium and we perturb the system at $t=0$, resulting in a change $\Delta x(0) = x(0) - x^\dagger$.
Taylor expansion around $x^\dagger$ (and omitting higher order terms) gives
$$
f(\Delta x) = f(x^\dagger) + J(x^\dagger)\Delta x + \ldots,
$$
where $J\rvert_{x=x^\dagger}$ the Jacobian matrix evaluated at $x^\dagger$ with
$J_{ij} = \frac{\partial f_i}{\partial x_j}$.
In theoretical ecology, the Jacobian evaluated at $x^\dagger$ is called the <em>community matrix</em>
$$
M = J(x^\dagger)\rvert_{x=x^\dagger}
$$
This matrix details the effect of increasing the density of one species on any other species around the equilibrium point.
Interestingly, as <a href=https://link.springer.com/content/pdf/10.1038/238413a0.pdf>May, 1927</a> pointed out, random matrix theory shows that the eigenvalues of $M$ determine the stability of the equilibrium $x^\dagger$.
In short, if all eigenvalues $\lambda_i$ have negative real parts, then the system will eventually return to $x^\dagger$ after a perturbation.
As a result, it suffices to check if the &lsquo;rightmost&rsquo; eigenvalue $\lambda_r$ (i.e. the eigenvalue with the largest real part) has a negative real part.
If that is the case, then the equilibrium is stable.</p><h2 id=random-matrix-theory-the-distribution-of-eigenvalues-and-community-stability>Random matrix theory: the distribution of eigenvalues and community stability</h2><p>Interestingly, the distribution of eigenvalues can be computed for large random communities
(i.e communities for which $n\rightarrow \infty$) of which the components of the community matrix are random with mean $0$ and variance $\sigma^2$.
While the specific form of the distribution was conjectured for long, the proof for the law is still relatively young (see <a href=https://projecteuclid.org/journals/annals-of-probability/volume-38/issue-5/Random-matrices-Universality-of-ESDs-and-the-circular-law/10.1214/10-AOP534.full>Tao, Vu, 2010</a>).
Here I will highlight the so-called <strong>circular law</strong> (but see below for the <strong>elliptic law</strong>) of the distribution of eigenvalues of random communities.</p><h3 id=circular-law>Circular law</h3><p>For a random $n\times n$ matrix with coefficients $X_{ij}$ random with $\mathbb{E}[X_{ij}] = 0$ and $\mathbb{E}[X_{ij}^2] = 1$, the empirical spectral distribution of $X/\sqrt{n}$ converges as $n\rightarrow \infty$ to</p><p>$$
\mu(\lambda) =
\cases{
1/\pi \quad &\text{if} \quad \text{Re}(\lambda)^2 + \text{Im}(\lambda)^2 \leq 1 \cr
0 \quad &\text{otherwise}
}
$$</p><p>This law can be used to compute the radius of the eigenvalue distribution of some community matrices of interest.</p><h3 id=on-the-stability-of-random-communities>On the stability of random communities</h3><p>In particular, the matrix that May studied is defined as follows.
Consider a community matrix $A$ that has elements $A_{ij}=0$ with probability $1-P$ and $A_{ij}\sim p(0;\sigma^2)$ with probability $P$.
The diagonal elements are set to $-d$.
This gives a matrix of which the elements have mean $0$ and variance $P\sigma^2$.
We find the normalized matrix $M = A/\sqrt{P\sigma^2}$ to have unit variance of its random elements.
The distribution of eigenvalues of $M$ follows the circular law for $n$ large.
The radius of the circle can be computed as we find $A/\sqrt{nP\sigma^2} \rightarrow 1$, thus the radius of the circle wherein all eigenvalues lie is given by
$$
R = \sqrt{nP\sigma^2}.
$$
Recall that for the equilibrium to be stable we need the rightmost eigenvalue to have a negative real part.
In other words,
$$
-d + \sqrt{nP\sigma^2} &lt; 0.
$$
In May&rsquo;s case, he defined $d=1$, which leads to his now famous result $\sigma &lt; (nP)^{-1/2}$ for a stable community.
From this inequality he notices that if the number of species $n$ is large, then the number of interactions between species (sampled with prob. $1-P$) should be low (i.e. $P$ large), <em>or</em>
the variance of the distribution should be small.
As a result, he concluded that heterogeneous ecological communities (large $\sigma$) with many members and interactions (high $n$ and $P$) cannot be stable.</p><h3 id=random-communities-are-not-just-random>Random communities are not &lsquo;just&rsquo; random</h3><p>However, as noted by Allesina, the effect of species $i$ on species $j$ (and vice-versa) are typically not independent (as assumed by May).
For example, if two species are competitors, then we expect $X_{ji}$ to be negative if $X_{ij}$ is negative.
Another example, if one species consumes another species (predator-prey), then we expect $X_{ji}$ to have an opposite sign than $X_{ij}$.
Therefore, a more realistic model of a random community matrix would therefore sample the elements of $M$ from a bivariate distribution instead.
In this case, the circular law becomes an <strong>elliptic law</strong>.</p><h4 id=the-elliptic-law>The elliptic law</h4><p>For a random $n\times n$ matrix in which the pairs of coefficients $(X_{ij}, X_{ji})$ are sampled independently from a bivariate distribution with mean $(0,0)^T$ and covariance $\Sigma = \left(\begin{matrix} 1 & \rho \cr \rho & 1 \end{matrix}\right)$, the empirical spectral distribution of $X/\sqrt{n}$ converges to the elliptic law
$$
\mu(\lambda) =
\begin{cases}
\frac{1}{\pi(1-\rho^2} \quad &\text{if} \quad
\frac{\text{Re}(\lambda)^2}{(1+\rho)^2} + \frac{\text{Im}(\lambda)^2}{(1-\rho)^2}
\leq 1
\cr
0 \quad &\text{otherwise}
\end{cases}
$$
(Note that when $\rho=0$ the law converges to the circular law.)</p><h2 id=some-code-examples>Some code examples</h2><p>To highlight the truth behind these laws, let us plot the eigenvalue distribution of a few matrices using <code>Julia</code>.
For the full code, please check <a href=https://github.com/johannesnauta/programming-julia/tree/main/Population-dynamics>my github repository</a>.
Below, let us define some functions that generate three types of matrices: May&rsquo;s matrix, a competition mutualism matrix, and a predator-prey matrix.</p><h3 id=mays-matrix>May&rsquo;s matrix</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#e6db74>&#34;Generate a matrix M that follows May&#39;s assumptions: 
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 1. Elements Mᵢⱼ are 0 with prob. P with i≠j
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 2. Elements are sampled from a zero-mean distribution with variance σ with prob. 1-P
</span></span></span><span style=display:flex><span><span style=color:#e6db74> 3. Diagonal elements Mᵢᵢ=-r, with r the self-regulation term
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> GenerateMayMatrix(n<span style=color:#f92672>::</span><span style=color:#66d9ef>Int64</span>, P<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, σ<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, r<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Initialize random matrix distributed as random normal with variance σ²</span>
</span></span><span style=display:flex><span>    M <span style=color:#f92672>=</span> σ <span style=color:#f92672>.*</span> randn(n,n)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Remove random connections with prob. P </span>
</span></span><span style=display:flex><span>    M <span style=color:#f92672>=</span> M <span style=color:#f92672>.*</span> (rand(n,n) <span style=color:#f92672>.&lt;</span> P)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Set diagonal elements</span>
</span></span><span style=display:flex><span>    M[diagind(M)] <span style=color:#f92672>.=</span> <span style=color:#f92672>-</span>r
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> M
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p><img src=/images/May.png alt="May&rsquo;s matrix" title="May's matrix"></p><p>Each point in the plot is an eigenvalue of a matrix where $n=250$, $P=0.25$, $\sigma=1$, $d=1$.
Notice the circular distribution of $\lambda$ with radius $\sqrt{nP\sigma^2}$.</p><h3 id=allesina-and-tang-matrices>Allesina and Tang matrices</h3><p>Generate a matrices that follows Allesina&rsquo;s and Tang&rsquo;s assumptions:</p><ol><li>Effects of species $i$ on species $j$ are typically not independent;<ul><li>(a.) When there is competition between species $i$ and $j$, both $M_{ij}$ and $M_{ji}$ should be negative</li><li>(b.) When there is consumption (i.e. predator-prey), then when $M_{ij}>0$ we have $M_{ji}&lt;0$</li></ul></li><li>As a result, interactions are sampled in pairs from a bivariate distribution</li></ol><h4 id=competition-mutualism-matrix>Competition-mutualism matrix</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>function</span> GenerateCompetitionMutualismMatrix(n<span style=color:#f92672>::</span><span style=color:#66d9ef>Int64</span>, P<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, σ<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, r<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Generate community matrix that has the following constraints </span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># (i., 1a.) sign(Mᵢⱼ) = sign(Mⱼᵢ)  (i.e. mutualism if sign()&gt;0 and competition otherwise)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># (ii.)     Mᵢⱼ ~ p(0;σ)</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># Initialize random matrix </span>
</span></span><span style=display:flex><span>    M <span style=color:#f92672>=</span> σ <span style=color:#f92672>.*</span> randn(n,n)
</span></span><span style=display:flex><span>    <span style=color:#75715e>#/ Force signs to be equal as per (1.)</span>
</span></span><span style=display:flex><span>    S <span style=color:#f92672>=</span> tril(sign<span style=color:#f92672>.</span>(M))
</span></span><span style=display:flex><span>    <span style=color:#75715e># Remove random connections with prob. 1-P </span>
</span></span><span style=display:flex><span>    S <span style=color:#f92672>=</span> S <span style=color:#f92672>.*</span> LowerTriangular(rand(n,n) <span style=color:#f92672>.&lt;</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>-</span>P))
</span></span><span style=display:flex><span>    <span style=color:#75715e># Generate matrix with equal sign</span>
</span></span><span style=display:flex><span>    S <span style=color:#f92672>=</span> S <span style=color:#f92672>.+</span> triu(transpose(S), <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Ensure (1.)</span>
</span></span><span style=display:flex><span>    M <span style=color:#f92672>=</span> abs<span style=color:#f92672>.</span>(M) <span style=color:#f92672>.*</span> S
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#/ Set diagonal elements</span>
</span></span><span style=display:flex><span>    M[diagind(M)] <span style=color:#f92672>.=</span> <span style=color:#f92672>-</span>r
</span></span><span style=display:flex><span>    <span style=color:#75715e>#/ Return</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> M
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p><img src=/images/CompMutu.png alt="Competition-mutualism matrix" title="Scatterplot for eigenvalues of matrix for the competition-mutualism assumptions"></p><p>Competition and mutualism results in a horizontally stretched ellipse.</p><h4 id=predator-prey-matrix>Predator-prey matrix</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#66d9ef>function</span> GeneratePredatorPreyMatrix(n<span style=color:#f92672>::</span><span style=color:#66d9ef>Int64</span>, P<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, σ<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>, r<span style=color:#f92672>::</span><span style=color:#66d9ef>Float64</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Generate community matrix that has the following constraints </span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># (i., 1b.) sign(Mᵢⱼ) = -sign(Mⱼᵢ)  (i.e. predator-prey)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># (ii.)     Mᵢⱼ ~ p(0;σ)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Initialize random matrix </span>
</span></span><span style=display:flex><span>    M <span style=color:#f92672>=</span> σ <span style=color:#f92672>.*</span> randn(n,n)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#/ Force signs to be opposite as per (1.)</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Compute random lower triangular matrix to ensure opposite signs</span>
</span></span><span style=display:flex><span>    L <span style=color:#f92672>=</span> LowerTriangular(rand(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>:</span><span style=color:#ae81ff>2</span><span style=color:#f92672>:</span><span style=color:#ae81ff>1</span>,n,n))
</span></span><span style=display:flex><span>    <span style=color:#75715e># Remove random connections with prob. 1-P </span>
</span></span><span style=display:flex><span>    L <span style=color:#f92672>=</span> L <span style=color:#f92672>.*</span> (LowerTriangular(rand(n,n)) <span style=color:#f92672>.&lt;</span> (<span style=color:#ae81ff>1</span><span style=color:#f92672>-</span>P))
</span></span><span style=display:flex><span>    <span style=color:#75715e># Generate matrix with opposite sign</span>
</span></span><span style=display:flex><span>    S <span style=color:#f92672>=</span> L <span style=color:#f92672>.+</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>.*</span> triu(transpose(L), <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># Force signs to be opposite as per (1.)</span>
</span></span><span style=display:flex><span>    M <span style=color:#f92672>=</span> abs<span style=color:#f92672>.</span>(M) <span style=color:#f92672>.*</span> S
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#/ Set diagonal elements</span>
</span></span><span style=display:flex><span>    M[diagind(M)] <span style=color:#f92672>.=</span> <span style=color:#f92672>-</span>r
</span></span><span style=display:flex><span>    <span style=color:#75715e>#/ Return </span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> M
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><p><img src=/images/PredPrey.png alt="Predator-prey matrix" title="Scatterplot for eigenvalues of matrix for the predator-prey assumptions"></p><p>The predator-prey assumption leads to a vertically strechted ellipse.</p><h2 id=plots>Plots</h2><p>We can plot the &lsquo;distribution&rsquo; of eigenvalues simply by making scatter plots of all the eigenvalues for a few matrices.
The above plots were generated with the following <code>Julia</code> module.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-julia data-lang=julia><span style=display:flex><span><span style=color:#75715e>#/ Load libraries </span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Plots, LaTeXStrings, Random, LinearAlgebra
</span></span><span style=display:flex><span>plot_font <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;Computer Modern&#34;</span>
</span></span><span style=display:flex><span>default(fontfamily<span style=color:#f92672>=</span>plot_font)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> PlotEigenvalues!(M<span style=color:#f92672>::</span><span style=color:#66d9ef>Matrix</span>{<span style=color:#66d9ef>Float64</span>}; pl<span style=color:#f92672>=</span>nothing)
</span></span><span style=display:flex><span>    <span style=color:#75715e>#/ Initalize plot </span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pl <span style=color:#f92672>===</span> nothing
</span></span><span style=display:flex><span>        pl <span style=color:#f92672>=</span> scatter(
</span></span><span style=display:flex><span>            aspect_ratio<span style=color:#f92672>=</span><span style=color:#e6db74>:equal</span>, theme<span style=color:#f92672>=</span><span style=color:#e6db74>:mute</span>, seriestype<span style=color:#f92672>=</span><span style=color:#e6db74>:scatter</span>,
</span></span><span style=display:flex><span>            xlabel <span style=color:#f92672>=</span> <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>extrm{Re}(\lambda)&#34;</span>, ylabel<span style=color:#f92672>=</span><span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>extrm{Im}(\lambda)&#34;</span>,
</span></span><span style=display:flex><span>            xlims<span style=color:#f92672>=</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>25</span>,<span style=color:#ae81ff>25</span>), ylims<span style=color:#f92672>=</span>(<span style=color:#f92672>-</span><span style=color:#ae81ff>25</span>,<span style=color:#ae81ff>25</span>),
</span></span><span style=display:flex><span>            xguidefontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>11</span>, yguidefontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>        pl <span style=color:#f92672>=</span> vline!(
</span></span><span style=display:flex><span>            [<span style=color:#ae81ff>0.</span>], linestyle<span style=color:#f92672>=</span><span style=color:#e6db74>:dash</span>, color<span style=color:#f92672>=</span><span style=color:#e6db74>:black</span>, 
</span></span><span style=display:flex><span>            label<span style=color:#f92672>=</span><span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>extrm{Re}(\lambda)=0&#34;</span>, legendfontsize<span style=color:#f92672>=</span><span style=color:#ae81ff>11</span>
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>end</span>
</span></span><span style=display:flex><span>    λ <span style=color:#f92672>=</span> eigvals(M)
</span></span><span style=display:flex><span>    pl <span style=color:#f92672>=</span> scatter!(
</span></span><span style=display:flex><span>        real(λ), imag(λ),
</span></span><span style=display:flex><span>        label<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;&#34;</span>, markersize<span style=color:#f92672>=</span><span style=color:#ae81ff>1.5</span>, msc<span style=color:#f92672>=</span><span style=color:#e6db74>:auto</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pl
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>
</span></span></code></pre></div><hr><h2 id=closing-thoughts>Closing thoughts</h2><p>The laws highlighted below show how useful random matrix theory can be in theoretical ecology.
Of course, real-world community matrices are often not random and depend on a big swath of (external) factors.
However, when communities are large, one can often extract distributions of the matrix components.
If the characteristics of these distributions are, for example, close to those highlighted above, then one can already say a lot about the stability of such systems.
It is also noteworthy to see that the actual distribution of elements of the distribution matrix does not matter much &ndash; as long as it is zero mean and has some finite variance.
This &rsquo;enables&rsquo; many of these distributions to be used, and undoubtedly some real-world communities have precisely such distributions of their community matrix.
Lately, however, more factors have been included in the community matrices that show the opposite of May&rsquo;s results, namely that highly interconnected and diverse communities might actually be more stable.
For now, the take-home message is that assuming simple mechanisms with ecological communities shows to lead to highly unstable communities.
As we look around us, most communities are actually very stable, so other things must be at play that influence the long-term stability of ecosystems.
Exciting!</p><a href=/>>> Home</a></main></div><footer><script>(function(){function n(e){var t,n,o,s=document.getElementsByTagName(e);for(n=0;n<s.length;n++)if(o=s[n],t=o.parentElement,t.childNodes.length===1){if(t.nodeName==="A"&&(t=t.parentElement,t.childNodes.length!=1))continue;t.nodeName==="P"&&(t.style.textAlign="center")}}for(var t=["img","embed","object"],e=0;e<t.length;e++)n(t[e])})()</script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      processEscapes: true
    }
    });
</script><script type=text/javascript src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><hr><p><a href=https://twitter.com/johannes_nauta>Twitter/X</a> |
<a href=https://github.com/johannesnauta>Github</a> |
<a href=https://keybase.io/jnauta>Keybase</a></p><p>(Theme built with <a href=https://gohugo.io/>Hugo</a> using the <a href=https://themes.gohugo.io/themes/hugo-classic/>Hugo-classic</a> made by
<a href=https://goodroot.ca/>Kellen Evan Person</a>)</p></footer></body></html>